<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hello Ajax</title>
</head>
<body>

<button id="helloBtn">Say Hello</button>
<hr>
<output></output>

<!--
  - why a script module
  - XHR Object name and note the wrapper from the old days
  - Setting headers and body (Law of Three Redux)
  - Use of the X-Header and why
  - Encoding x-www-urlencoded
  - onload vs onreadystatechange - the later is a bit more capable but less friendly!
  - Introducing SOP & CORS - the solution was on the server side
  - lack of error handling!
 -->
<script type="module">
    // use a type module to avoid poluting global name space will all our function names
    
    // avoid waiting until the full page load, jut wait until DOM is ready
    window.addEventListener('DOMContentLoaded', init);

    function init() {
        let el;

        el = document.getElementById('helloBtn').addEventListener('click', sayHello);
    }

    function sayHello() {
        let xhr = new XMLHttpRequest();

        // forming the law of 3 request line method, URL, and optional async/sync flag
        xhr.open('POST','http://localhost:3000/echo');

        // a header we could use on the server-side to determine if from JS or if from a form
        xhr.setRequestHeader('X-Sent-By','javascript');
        
        // the standard encoding
        xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');

        xhr.onload = function () {
            // TODO: refactor this to read the JSON and display the message instead of the raw JSON
            
            // how dangerous is it to just jam this content in here like this?
            document.querySelector('output').innerHTML = xhr.responseText;
        }

        // note the creation of the message body manually and proper encoding here
        xhr.send(`message=${encodeURIComponent('hello there it is ' + new Date())}`);
    }
</script>

</body>
</html>